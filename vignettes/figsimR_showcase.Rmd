---
title: "Using figsimR: Diagnosing the Variation Gap and Dissecting Community Assembly"
author: "Yiyi Dong"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Using figsimR: Diagnosing the Variation Gap and Dissecting Community Assembly}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
# Global chunk options for a fast, deterministic vignette
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.height = 4,
  dpi = 120,
  cache = FALSE
)

# We'll keep heavy computations disabled by default in the vignette.
RUN_HEAVY <- FALSE
```

```{r setup-library, echo=FALSE}
# set seed and load library in a separate, non-displayed chunk
set.seed(123)
library(figsimR)
```

# 1. Introduction: When theory meets variability

Ecologists have long recognized that natural communities exhibit large variability. `figsimR` operationalizes a mechanistic null workflow: we calibrate a baseline configuration modeling (BCM) to reproduce empirical means, then quantify the Variation Gap—the residual dispersion that the intrinsic model cannot capture. Finally, we use mechanism knockout experiments to dissect which internal processes maintain the theoretical structure.

This vignette shows the full workflow on a fig–wasp case study, with small defaults for speed. For the full reproduction (long runs), see the package website article “Reproducing the case study” (or run this vignette with `RUN_HEAVY <- TRUE`).

# 2. Data and quick look

We use an empirical dataset of fig wasp communities collected from *Ficus racemosa*. Each column is a species’ abundance; each row is one fig (community unit).

```{r load-data}
# Example data shipped with the package
data(observed_data)          # 935 x 6 abundance matrix (one row per fig)
data(parameter_list_default) # Named lists of biological parameters
data(species_list)           # Character vector of the six focal species

# Inspect the first rows
head(observed_data)
```

**Provenance.**
Aung, K. M., Chen, H.-H., Segar, S. T., Miao, B.-G., Peng, Y.-Q., & Liu, C. (2022). *Journal of Animal Ecology*, 91, 1303–1315. https://doi.org/10.1111/1365-2656.13701

# 3. Build the theoretical world (BCM)

## 3.1 Bootstrap empirical metrics (fast)

We summarize alpha, beta, and simple network metrics by bootstrapping figs. Defaults are small to keep this vignette snappy.

```{r bootstrap-metrics}
obs_metrics <- resample_observed_all_metrics(
  observed_df = observed_data,
  wasp_cols   = species_list,
  n_draws     = 50,     
  sample_n    = 100,    
  seed        = 42,
  calc_func   = calc_all_metrics
)

head(obs_metrics)
```

## 3.2 Parameter ranges for BCM calibration

We convert a parameter list into ranges for Latin hypercube exploration. We remove fixed items (interaction matrix/weight).

```{r param-ranges}
param_ranges <- parameter_list_default
param_ranges[c("interaction_matrix", "interaction_weight")] <- NULL
param_ranges <- convert_parameter_list_to_param_ranges(param_ranges)
str(param_ranges, max.level = 1)
```

## 3.3 Explore parameter space (short demo vs. full)

**Important:** LHS over thousands of samples × 1000‑fig simulations is expensive. In the vignette we either (A) load a precomputed result, or (B) run a tiny demo search. For full runs, set `RUN_HEAVY <- TRUE` and increase `n_samples`, `n_draws`, `sample_n`, and `num_figs`.

```{r explore-params}
# Optional: progress bars (kept OFF in vignette)
# progressr::handlers(global = TRUE); progressr::handlers("txtprogressbar")

# load a precomputed optimization (ship it in inst/extdata/)
lhs_file <- system.file("extdata", "lhs_optimize_result.rds", package = "figsimR")

if (file.exists(lhs_file)) {
  lhs_opt <- readRDS(lhs_file)
} else if (RUN_HEAVY) {
  lhs_opt <- explore_parameter_space_lhs(
    new_param_ranges        = param_ranges,
    observed_summary        = obs_metrics[, 1:10], # numeric summary columns
    num_figs                = 1000,
    n_draws                 = 500,
    sample_n                = 200,
    wasp_cols               = species_list,
    parameter_list_template = parameter_list_default,
    n_samples               = 5000,
    top_k                   = 5,
    n_cores                 = max(1, parallel::detectCores() - 1)
  )
} else {
  
  lhs_opt <- explore_parameter_space_lhs(
    new_param_ranges        = param_ranges,
    observed_summary        = obs_metrics[, 1:10],
    num_figs                = 200,
    n_draws                 = 20,
    sample_n                = 100,
    wasp_cols               = species_list,
    parameter_list_template = parameter_list_default,
    n_samples               = 50,    
    top_k                   = 1,
    n_cores                 = 1
  )
}

best_row <- lhs_opt[1, , drop = FALSE]
best_params <- rebuild_parameter_list_from_row(best_row, parameter_list_default)
```

## 3.4 Simulate the BCM with best parameters

```{r simulate-bcm}
sim_out <- simulate_figwasp_community(
  num_figs                = if (RUN_HEAVY) 1000 else 300,
  fecundity_mean          = best_params$fecundity_mean,
  fecundity_dispersion    = best_params$fecundity_dispersion,
  entry_mu                = best_params$entry_mu,
  entry_size              = best_params$entry_size,
  entry_priority          = best_params$entry_priority,
  species_roles           = best_params$species_roles,
  max_entry_table         = best_params$max_entry_table,
  enable_drop             = TRUE,
  drop_cancels_emergence  = FALSE,
  entry_distribution      = "lognormal",
  interaction_matrix      = best_params$interaction_matrix,
  interaction_weight      = 0,
  egg_success_prob        = best_params$egg_success_prob,
  egg_success_prob_by_phase = best_params$egg_success_prob_by_phase,
  layer_preference        = best_params$layer_preference,
  use_layering            = TRUE,
  seed                    = 42
)

sim_df <- sim_out$summary
head(sim_df)
```

# 4. Quantify the Variation Gap

We compare Observed vs Simulated by resampling simulated figs to the same sample size and computing identical metrics.

```{r quantify-gap}
sim_metrics <- resample_simulated_metrics(
  n_draws   = if (RUN_HEAVY) 500 else 50,
  sample_n  = if (RUN_HEAVY) 200 else 100,
  num_figs  = nrow(sim_df),
  simulator_func = function(...) list(summary = sim_df),  # reuse existing sim
  calc_func = calc_all_metrics,
  wasp_cols = paste0("emergence_", species_list)
)

# Combine tags and run ordination/dispersion tests (example using NMDS + betadisper)
obs_tag <- observed_data
sim_tag <- sim_df[, paste0("emergence_", species_list), drop = FALSE]

obs_tag$group <- "Observed"
sim_tag$group <- "Simulated"

# Ensure column names match for rbind
colnames(sim_tag) <- gsub("^emergence_", "", colnames(sim_tag))

combined <- rbind(obs_tag, sim_tag)

combined <- combined[rowSums(combined[ , species_list]) > 0, ]
sp_mat   <- vegan::decostand(combined[ , species_list], method = "hellinger")
nmds     <- vegan::metaMDS(sp_mat, distance = "euclidean", k = 2, trymax = 100)

# Dispersion comparison
dist_eu  <- vegan::vegdist(sp_mat, "euclidean")
bd       <- vegan::betadisper(dist_eu, group = factor(combined$group))
bd_perm  <- vegan::permutest(bd, permutations = 499)

bd_perm
```

The Variation Gap occurs when the simulated cloud matches means but shows less multivariate dispersion than what is seen (the intrinsic model understates actual variability).

# 5. Dissect internal mechanisms (knockouts)

We switch off individual modules (e.g., spatial layering, host sanctions) to quantify each mechanism’s contribution relative to the BCM

```{r knockouts}
# Example: remove spatial layering
sim_no_space <- simulate_figwasp_community(
  num_figs = if (RUN_HEAVY) 1000 else 300,
  fecundity_mean       = best_params$fecundity_mean,
  fecundity_dispersion = best_params$fecundity_dispersion,
  entry_mu             = best_params$entry_mu,
  entry_size           = best_params$entry_size,
  entry_priority       = best_params$entry_priority,
  species_roles        = best_params$species_roles,
  max_entry_table      = best_params$max_entry_table,
  enable_drop          = TRUE,
  drop_cancels_emergence = FALSE,
  entry_distribution   = "lognormal",
  interaction_matrix   = best_params$interaction_matrix,
  interaction_weight   = 0,
  egg_success_prob     = best_params$egg_success_prob,
  egg_success_prob_by_phase = best_params$egg_success_prob_by_phase,
  layer_preference     = best_params$layer_preference,
  use_layering         = FALSE,  # KO here
  seed                 = 43
)$summary

# Summarize metrics for BCM vs. KO
bcm_metrics  <- resample_metrics_from_simulation(sim_df,       n_reps = 50, sample_size = 100, seed = 1)
ko_metrics   <- resample_metrics_from_simulation(sim_no_space, n_reps = 50, sample_size = 100, seed = 1)

# Loss vs empirical means (smaller = better to observed)
obs_means_row <- as.data.frame(t(colMeans(obs_metrics[ , setdiff(names(obs_metrics), "source") ], na.rm = TRUE)))
bcm_loss      <- calculate_metric_loss(bcm_metrics, obs_means_row)
ko_loss       <- calculate_metric_loss(ko_metrics,  obs_means_row)

list(BCM_total_loss = bcm_loss$total_loss,
     KO_no_space_total_loss = ko_loss$total_loss)
```

The bigger the loss jump when a module is removed, the more important that module is for reproducing community structure within the intrinsic envelope.

# 6. Practical notes for users

* **Speed vs. rigor.** The vignette runs with small `n_draws`, `sample_n`, and `n_samples`. For real analyses, increase these substantially.

* **Reproducibility.** Use `set.seed()` everywhere. If you enable parallelism, document RNG streams.

* **Progress bars.** `progressr::handlers()` may conflict with test runners—keep them off by default in vignettes.

* **Precomputed objects.** For long workflows, ship `.rds` results in `inst/extdata/` and load them when available (as shown above).

# 7. Session info

```{r session-info}
sessionInfo()
